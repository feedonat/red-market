/* ngx-moment (c) 2015, 2016 Uri Shaked / MIT Licence */
import { __decorate } from "tslib";
import { Pipe, ChangeDetectorRef, PipeTransform, EventEmitter, OnDestroy, NgZone, } from '@angular/core';
import * as moment from 'moment';
var momentConstructor = moment;
var CalendarPipe = /** @class */ (function () {
    function CalendarPipe(cdRef, ngZone) {
        var _this = this;
        this.cdRef = cdRef;
        this.ngZone = ngZone;
        // using a single static timer for all instances of this pipe for performance reasons
        CalendarPipe_1.initTimer(ngZone);
        CalendarPipe_1.refs++;
        // values such as Today will need to be replaced with Yesterday after midnight,
        // so make sure we subscribe to an EventEmitter that we set up to emit at midnight
        this.midnightSub = CalendarPipe_1.midnight.subscribe(function () {
            _this.ngZone.run(function () { return _this.cdRef.markForCheck(); });
        });
    }
    CalendarPipe_1 = CalendarPipe;
    CalendarPipe.prototype.transform = function (value) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var formats = null;
        var referenceTime = null;
        for (var i = 0, len = args.length; i < len; i++) {
            if (args[i] !== null) {
                if (typeof args[i] === 'object' && !moment.isMoment(args[i])) {
                    formats = args[i];
                }
                else {
                    referenceTime = momentConstructor(args[i]);
                }
            }
        }
        return momentConstructor(value).calendar(referenceTime, formats);
    };
    CalendarPipe.prototype.ngOnDestroy = function () {
        if (CalendarPipe_1.refs > 0) {
            CalendarPipe_1.refs--;
        }
        if (CalendarPipe_1.refs === 0) {
            CalendarPipe_1.removeTimer();
        }
        this.midnightSub.unsubscribe();
    };
    CalendarPipe.initTimer = function (ngZone) {
        // initialize the timer
        if (!CalendarPipe_1.midnight) {
            CalendarPipe_1.midnight = new EventEmitter();
            if (typeof window !== 'undefined') {
                var timeToUpdate_1 = CalendarPipe_1._getMillisecondsUntilUpdate();
                CalendarPipe_1.timer = ngZone.runOutsideAngular(function () {
                    return window.setTimeout(function () {
                        // emit the current date
                        CalendarPipe_1.midnight.emit(new Date());
                        // refresh the timer
                        CalendarPipe_1.removeTimer();
                        CalendarPipe_1.initTimer(ngZone);
                    }, timeToUpdate_1);
                });
            }
        }
    };
    CalendarPipe.removeTimer = function () {
        if (CalendarPipe_1.timer) {
            window.clearTimeout(CalendarPipe_1.timer);
            CalendarPipe_1.timer = null;
            CalendarPipe_1.midnight = null;
        }
    };
    CalendarPipe._getMillisecondsUntilUpdate = function () {
        var now = momentConstructor();
        var tomorrow = momentConstructor().startOf('day').add(1, 'days');
        var timeToMidnight = tomorrow.valueOf() - now.valueOf();
        return timeToMidnight + 1000; // 1 second after midnight
    };
    var CalendarPipe_1;
    /**
     * Internal reference counter, so we can clean up when no instances are in use
     */
    CalendarPipe.refs = 0;
    CalendarPipe.timer = null;
    CalendarPipe.midnight = null;
    CalendarPipe.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: NgZone }
    ]; };
    CalendarPipe = CalendarPipe_1 = __decorate([
        Pipe({ name: 'amCalendar', pure: false })
    ], CalendarPipe);
    return CalendarPipe;
}());
export { CalendarPipe };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL25neC1tb21lbnQvIiwic291cmNlcyI6WyJjYWxlbmRhci5waXBlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHdEQUF3RDs7QUFFeEQsT0FBTyxFQUNMLElBQUksRUFDSixpQkFBaUIsRUFDakIsYUFBYSxFQUNiLFlBQVksRUFDWixTQUFTLEVBQ1QsTUFBTSxHQUNQLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFDO0FBR2pDLElBQU0saUJBQWlCLEdBQUcsTUFBTSxDQUFDO0FBR2pDO0lBV0Usc0JBQW9CLEtBQXdCLEVBQVUsTUFBYztRQUFwRSxpQkFXQztRQVhtQixVQUFLLEdBQUwsS0FBSyxDQUFtQjtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7UUFDbEUscUZBQXFGO1FBQ3JGLGNBQVksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFL0IsY0FBWSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXBCLCtFQUErRTtRQUMvRSxrRkFBa0Y7UUFDbEYsSUFBSSxDQUFDLFdBQVcsR0FBRyxjQUFZLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQztZQUNqRCxLQUFJLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxjQUFNLE9BQUEsS0FBSSxDQUFDLEtBQUssQ0FBQyxZQUFZLEVBQUUsRUFBekIsQ0FBeUIsQ0FBQyxDQUFDO1FBQ25ELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztxQkF0QlUsWUFBWTtJQXdCdkIsZ0NBQVMsR0FBVCxVQUFVLEtBQXlCO1FBQUUsY0FBYzthQUFkLFVBQWMsRUFBZCxxQkFBYyxFQUFkLElBQWM7WUFBZCw2QkFBYzs7UUFDakQsSUFBSSxPQUFPLEdBQVEsSUFBSSxDQUFDO1FBQ3hCLElBQUksYUFBYSxHQUFRLElBQUksQ0FBQztRQUU5QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxHQUFHLEdBQUcsSUFB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QUFFLElBQUksRUFBRSxLQUFLLEVBQUUsQ0FBQztPQUM3QixZQUFZLENBdUZ4QjtJQUFELG1CQUFDO0NBQUEsQUF2RkQsSUF1RkM7U0F2RlksWUFBWSIsInNvdXJjZXNDb250ZW50IjpbIi8qIG5neC1tb21lbnQgKGMpIDIwMTUsIDIwMTYgVXJpIFNoYWtlZCAvIE1JVCBMaWNlbmNlICovXG5cbmltcG9ydCB7XG4gIFBpcGUsXG4gIENoYW5nZURldGVjdG9yUmVmLFxuICBQaXBlVHJhbnNmb3JtLFxuICBFdmVudEVtaXR0ZXIsXG4gIE9uRGVzdHJveSxcbiAgTmdab25lLFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5cbmNvbnN0IG1vbWVudENvbnN0cnVjdG9yID0gbW9tZW50O1xuXG5AUGlwZSh7IG5hbWU6ICdhbUNhbGVuZGFyJywgcHVyZTogZmFsc2UgfSlcbmV4cG9ydCBjbGFzcyBDYWxlbmRhclBpcGUgaW1wbGVtZW50cyBQaXBlVHJhbnNmb3JtLCBPbkRlc3Ryb3kge1xuICAvKipcbiAgICogSW50ZXJuYWwgcmVmZXJlbmNlIGNvdW50ZXIsIHNvIHdlIGNhbiBjbGVhbiB1cCB3aGVuIG5vIGluc3RhbmNlcyBhcmUgaW4gdXNlXG4gICAqL1xuICBwcml2YXRlIHN0YXRpYyByZWZzID0gMDtcblxuICBwcml2YXRlIHN0YXRpYyB0aW1lcjogbnVtYmVyIHwgbnVsbCA9IG51bGw7XG4gIHByaXZhdGUgc3RhdGljIG1pZG5pZ2h0OiBFdmVudEVtaXR0ZXI8RGF0ZT4gfCBudWxsID0gbnVsbDtcblxuICBwcml2YXRlIG1pZG5pZ2h0U3ViOiBTdWJzY3JpcHRpb247XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjZFJlZjogQ2hhbmdlRGV0ZWN0b3JSZWYsIHByaXZhdGUgbmdab25lOiBOZ1pvbmUpIHtcbiAgICAvLyB1c2luZyBhIHNpbmdsZSBzdGF0aWMgdGltZXIgZm9yIGFsbCBpbnN0YW5jZXMgb2YgdGhpcyBwaXBlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgQ2FsZW5kYXJQaXBlLmluaXRUaW1lcihuZ1pvbmUpO1xuXG4gICAgQ2FsZW5kYXJQaXBlLnJlZnMrKztcblxuICAgIC8vIHZhbHVlcyBzdWNoIGFzIFRvZGF5IHdpbGwgbmVlZCB0byBiZSByZXBsYWNlZCB3aXRoIFllc3RlcmRheSBhZnRlciBtaWRuaWdodCxcbiAgICAvLyBzbyBtYWtlIHN1cmUgd2Ugc3Vic2NyaWJlIHRvIGFuIEV2ZW50RW1pdHRlciB0aGF0IHdlIHNldCB1cCB0byBlbWl0IGF0IG1pZG5pZ2h0XG4gICAgdGhpcy5taWRuaWdodFN1YiA9IENhbGVuZGFyUGlwZS5taWRuaWdodC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgdGhpcy5uZ1pvbmUucnVuKCgpID0+IHRoaXMuY2RSZWYubWFya0ZvckNoZWNrKCkpO1xuICAgIH0pO1xuICB9XG5cbiAgdHJhbnNmb3JtKHZhbHVlOiBtb21lbnQuTW9tZW50SW5wdXQsIC4uLmFyZ3M6IGFueVtdKTogYW55IHtcbiAgICBsZXQgZm9ybWF0czogYW55ID0gbnVsbDtcbiAgICBsZXQgcmVmZXJlbmNlVGltZTogYW55ID0gbnVsbDtcblxuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhcmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoYXJnc1tpXSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbaV0gPT09ICdvYmplY3QnICYmICFtb21lbnQuaXNNb21lbnQoYXJnc1tpXSkpIHtcbiAgICAgICAgICBmb3JtYXRzID0gYXJnc1tpXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZlcmVuY2VUaW1lID0gbW9tZW50Q29uc3RydWN0b3IoYXJnc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbW9tZW50Q29uc3RydWN0b3IodmFsdWUpLmNhbGVuZGFyKHJlZmVyZW5jZVRpbWUsIGZvcm1hdHMpO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKTogdm9pZCB7XG4gICAgaWYgKENhbGVuZGFyUGlwZS5yZWZzID4gMCkge1xuICAgICAgQ2FsZW5kYXJQaXBlLnJlZnMtLTtcbiAgICB9XG5cbiAgICBpZiAoQ2FsZW5kYXJQaXBlLnJlZnMgPT09IDApIHtcbiAgICAgIENhbGVuZGFyUGlwZS5yZW1vdmVUaW1lcigpO1xuICAgIH1cblxuICAgIHRoaXMubWlkbmlnaHRTdWIudW5zdWJzY3JpYmUoKTtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIGluaXRUaW1lcihuZ1pvbmU6IE5nWm9uZSkge1xuICAgIC8vIGluaXRpYWxpemUgdGhlIHRpbWVyXG4gICAgaWYgKCFDYWxlbmRhclBpcGUubWlkbmlnaHQpIHtcbiAgICAgIENhbGVuZGFyUGlwZS5taWRuaWdodCA9IG5ldyBFdmVudEVtaXR0ZXI8RGF0ZT4oKTtcbiAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCB0aW1lVG9VcGRhdGUgPSBDYWxlbmRhclBpcGUuX2dldE1pbGxpc2Vjb25kc1VudGlsVXBkYXRlKCk7XG4gICAgICAgIENhbGVuZGFyUGlwZS50aW1lciA9IG5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIC8vIGVtaXQgdGhlIGN1cnJlbnQgZGF0ZVxuICAgICAgICAgICAgQ2FsZW5kYXJQaXBlLm1pZG5pZ2h0LmVtaXQobmV3IERhdGUoKSk7XG5cbiAgICAgICAgICAgIC8vIHJlZnJlc2ggdGhlIHRpbWVyXG4gICAgICAgICAgICBDYWxlbmRhclBpcGUucmVtb3ZlVGltZXIoKTtcbiAgICAgICAgICAgIENhbGVuZGFyUGlwZS5pbml0VGltZXIobmdab25lKTtcbiAgICAgICAgICB9LCB0aW1lVG9VcGRhdGUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyByZW1vdmVUaW1lcigpIHtcbiAgICBpZiAoQ2FsZW5kYXJQaXBlLnRpbWVyKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KENhbGVuZGFyUGlwZS50aW1lcik7XG4gICAgICBDYWxlbmRhclBpcGUudGltZXIgPSBudWxsO1xuICAgICAgQ2FsZW5kYXJQaXBlLm1pZG5pZ2h0ID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBfZ2V0TWlsbGlzZWNvbmRzVW50aWxVcGRhdGUoKSB7XG4gICAgY29uc3Qgbm93ID0gbW9tZW50Q29uc3RydWN0b3IoKTtcbiAgICBjb25zdCB0b21vcnJvdyA9IG1vbWVudENvbnN0cnVjdG9yKCkuc3RhcnRPZignZGF5JykuYWRkKDEsICdkYXlzJyk7XG4gICAgY29uc3QgdGltZVRvTWlkbmlnaHQgPSB0b21vcnJvdy52YWx1ZU9mKCkgLSBub3cudmFsdWVPZigpO1xuICAgIHJldHVybiB0aW1lVG9NaWRuaWdodCArIDEwMDA7IC8vIDEgc2Vjb25kIGFmdGVyIG1pZG5pZ2h0XG4gIH1cbn1cbiJdfQ==